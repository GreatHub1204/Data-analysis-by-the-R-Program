(num_cond_obs_price[i,i] /
lambda_est_mat[i,i] ^ 2) *
matrix(1, num_price_states, num_price_states)[-i,-i]
lambda_se <- c(
lambda_se,
# 逆行列の対角要素の平方根が標準誤差になる
sqrt(diag(solve(Infomat_price_est)))
)
}
matrix(1, num_price_states, num_price_states)[-2,-2]
Infomat_price_est
lambda_se
lambda_se <- c()
for (i in 1:num_price_states) {
# 最尤法のフィッシャー情報量を求める
Infomat_price_est <-
diag(num_cond_obs_price[i,],
num_price_states)[-i,-i] /
(lambda_est_mat[-i,-i] ^ 2) +
(num_cond_obs_price[i,i] /
lambda_est_mat[i,i] ^ 2) *
matrix(1, num_price_states, num_price_states)[-i,-i]
lambda_se <- c(
lambda_se,
# 逆行列の対角要素の平方根が標準誤差になる
sqrt(diag(solve(Infomat_price_est)))
)
}
matrix(1, num_price_states, num_price_states)[-2,-2]
Infomat_price_est
lambda_se
lambda_se_mat
lambda_se_mat <-
c(0, lambda_se[1], lambda_se[2], lambda_se[3], lambda_se[4], lambda_se[5],
lambda_se[6], 0, lambda_se[7], lambda_se[8], lambda_se[9], lambda_se[10],
lambda_se[11], lambda_se[12], 0, lambda_se[13], lambda_se[14], lambda_se[15],
lambda_se[16], lambda_se[17], lambda_se[18], 0, lambda_se[19], lambda_se[20],
lambda_se[21], lambda_se[22], lambda_se[23], lambda_se[24], 0, lambda_se[25],
lambda_se[26], lambda_se[27], lambda_se[28], lambda_se[29], lambda_se[30], 0)
lambda_se_mat
lambda_se_mat <-
c(0, lambda_se[1], lambda_se[2], lambda_se[3], lambda_se[4], lambda_se[5],
lambda_se[6], 0, lambda_se[7], lambda_se[8], lambda_se[9], lambda_se[10],
lambda_se[11], lambda_se[12], 0, lambda_se[13], lambda_se[14], lambda_se[15],
lambda_se[16], lambda_se[17], lambda_se[18], 0, lambda_se[19], lambda_se[20],
lambda_se[21], lambda_se[22], lambda_se[23], lambda_se[24], 0, lambda_se[25],
lambda_se[26], lambda_se[27], lambda_se[28], lambda_se[29], lambda_se[30], 0) %>%
matrix(ncol = num_price_states, nrow = num_price_states, byrow=T)
lambda_se_mat
typeof(lambda_se_mat)
t(lambda_est_mat)
lambda_se_mat <-
c(0, lambda_se[1], lambda_se[2], lambda_se[3], lambda_se[4], lambda_se[5],
lambda_se[6], 0, lambda_se[7], lambda_se[8], lambda_se[9], lambda_se[10],
lambda_se[11], lambda_se[12], 0, lambda_se[13], lambda_se[14], lambda_se[15],
lambda_se[16], lambda_se[17], lambda_se[18], 0, lambda_se[19], lambda_se[20],
lambda_se[21], lambda_se[22], lambda_se[23], lambda_se[24], 0, lambda_se[25],
lambda_se[26], lambda_se[27], lambda_se[28], lambda_se[29], lambda_se[30], 0) %>%
matrix(ncol = num_price_states, nrow = num_price_states, byrow=T)
lambda_se_mat
t(lambda_est_mat)
lambda_est
as.vector(t(lambda_est_mat))
lambda_est <- as.vector(t(lambda_est_mat))[c(-1,-8,-15,-22,-29,-36)]
lambda_est <- as.vector(t(lambda_est_mat))[c(-1,-8,-15,-22,-29,-36)]
lambda_se_mat <-
c(0, lambda_se[1], lambda_se[2], lambda_se[3], lambda_se[4], lambda_se[5],
lambda_se[6], 0, lambda_se[7], lambda_se[8], lambda_se[9], lambda_se[10],
lambda_se[11], lambda_se[12], 0, lambda_se[13], lambda_se[14], lambda_se[15],
lambda_se[16], lambda_se[17], lambda_se[18], 0, lambda_se[19], lambda_se[20],
lambda_se[21], lambda_se[22], lambda_se[23], lambda_se[24], 0, lambda_se[25],
lambda_se[26], lambda_se[27], lambda_se[28], lambda_se[29], lambda_se[30], 0) %>%
matrix(ncol = num_price_states, nrow = num_price_states, byrow=T)
lambda_se_mat
lambda_est
lambda_est_mat
lambda_est_mat <-
num_cond_obs_price / rowSums(num_cond_obs_price)
lambda_est_mat
mat_ij <- Vectorize(
function(i,j,mat) {mat[i,j]},
vectorize.args = c("i", "j"))
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat
mat_ij <- Vectorize(
function(i,j,mat) {mat[i,j]},
vectorize.args = c("i", "j"))
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat
start_time <- proc.time()
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
end_time <- proc.time()
cat("Runtime:\n")
print((end_time - start_time)[[3]])
theta_est_stat <- logit_stat_opt$par
theta_est_stat
hessian_stat <- numDeriv::hessian(func = logLH_stat, x = theta_est_stat,
state_df = state_df, df = data_gen)
theta_se_stat <- sqrt(diag(solve(-hessian_stat)))
dplyr::tibble(theta_est_stat, theta_se_stat)
trans_mat_hat <- list()
trans_mat_hat$not_buy <-
gen_mileage_trans(kappa_est)[,,1] %x% gen_price_trans(lambda_est)
trans_mat_hat$buy <-
gen_mileage_trans(kappa_est)[,,2] %x% gen_price_trans(lambda_est)
logLH <- function(theta, beta, trans_mat, state_df, df){
# 選択ごとの期待価値関数を計算
EV <- contraction(theta, beta, trans_mat, state_df)
# 選択毎の価値関数を定義する
U <- flow_utility(theta, state_df)
V_CS <- U + beta*EV
# 選択確率を計算
prob_C <- exp(V_CS) / rowSums(exp(V_CS))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C)))
}
start_time <- proc.time()
# 最適化
NFXP_opt <- optim(theta_true, logLH,
beta = beta, trans_mat = trans_mat_hat, state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
help Vectorize()
Vectorize()
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
logit_stat_opt
mat_ij <- Vectorize(
function(i,j,mat) {mat[i,j]},
vectorize.args = c("i", "j"))
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat
start_time <- proc.time()
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
logit_stat_opt
end_time <- proc.time()
cat("Runtime:\n")
print((end_time - start_time)[[3]])
theta_est_stat <- logit_stat_opt$par
theta_est_stat
data_gen
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
logit_stat_opt
logLH_stat
logLH_stat(theta_true, state_df, data_gen)
# 対数尤度を計算
mat_ij(df$state_id, df$action + 1, prob_C_stat)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
mat_ij(df$state_id, df$action + 1, prob_C_stat)
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
}
logLH_stat(theta_true, state_df, data_gen)
# 対数尤度を計算
prob_C_stat
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
prob_C_stat
}
logLH_stat(theta_true, state_df, data_gen)
typeof(aaaa)
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
prob_C_stat
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
prob_C_stat
}
aaaa = logLH_stat(theta_true, state_df, data_gen)
typeof(aaaa)
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
start_time <- proc.time()
data_gen
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
logit_stat_opt
flow_utility(theta_true, state_df)
start_time <- proc.time()
data_gen
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
logit_stat_opt
end_time <- proc.time()
cat("Runtime:\n")
print((end_time - start_time)[[3]])
theta_est_stat <- logit_stat_opt$par
theta_est_stat
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
prob_C_stat
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
prob_C_stat
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
prob_C_stat
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
print(prob_C_stat)
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
print(U)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
print(U)
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
mat_ij <- Vectorize(
function(i,j,mat) {mat[i,j]},
vectorize.args = c("i", "j"))
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df)
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
start_time <- proc.time()
data_gen
# 最適化
logit_stat_opt <- optim(theta_true, logLH_stat,
state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
logit_stat_opt
end_time <- proc.time()
cat("Runtime:\n")
print((end_time - start_time)[[3]])
theta_est_stat <- logit_stat_opt$par
theta_est_stat
hessian_stat <- numDeriv::hessian(func = logLH_stat, x = theta_est_stat,
state_df = state_df, df = data_gen)
theta_se_stat <- sqrt(diag(solve(-hessian_stat)))
theta_se_stat
hessian_stat
theta_true
state_df
flow_utility(theta_true, state_df)
logLH_stat(theta_true, state_df, data_gen2);
logLH_stat(theta_true, state_df, data_gen);
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
# 対数尤度を計算
#sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)));
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)));
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
print(mat_ij(df$state_id, df$action + 1, prob_C_stat));
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)));
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
#print(mat_ij(df$state_id, df$action + 1, prob_C_stat));
# 対数尤度を計算
#sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)));
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U))
#print(mat_ij(df$state_id, df$action + 1, prob_C_stat));
# 対数尤度を計算
#sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)));
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)));
}
logLH_stat(theta_true, state_df, data_gen)
# 対数尤度を計算
mat_ij(df$state_id, df$action + 1, prob_C_stat);
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
# 対数尤度を計算
mat_ij(df$state_id, df$action + 1, prob_C_stat);
}
logLH_stat(theta_true, state_df, data_gen)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C_stat)))
}
logLH_stat(theta_true, state_df, data_gen)
data_gen
data_gen
View(data_gen)
# 対数尤度を計算
mat_ij(df$state_id, df$action + 1, prob_C_stat)
logLH_stat <- function(theta, state_df, df){
# 選択毎の効用関数を求める
U <- flow_utility(theta, state_df);
# 選択確率を計算
prob_C_stat <- exp(U) / rowSums(exp(U));
# 対数尤度を計算
mat_ij(df$state_id, df$action + 1, prob_C_stat)
}
data_gen
logLH_stat(theta_true, state_df, data_gen)
hessian_stat
theta_se_stat <- sqrt(diag(solve(-hessian_stat)))
theta_se_stat
kapp_est
kappa_est
trans_mat_hat <- list()
trans_mat_hat$not_buy <-
gen_mileage_trans(kappa_est)[,,1] %x% gen_price_trans(lambda_est)
trans_mat_hat$buy <-
gen_mileage_trans(kappa_est)[,,2] %x% gen_price_trans(lambda_est)
logLH <- function(theta, beta, trans_mat, state_df, df){
# 選択ごとの期待価値関数を計算
EV <- contraction(theta, beta, trans_mat, state_df)
# 選択毎の価値関数を定義する
U <- flow_utility(theta, state_df)
V_CS <- U + beta*EV
# 選択確率を計算
prob_C <- exp(V_CS) / rowSums(exp(V_CS))
# 対数尤度を計算
sum(log(mat_ij(df$state_id, df$action + 1, prob_C)))
}
start_time <- proc.time()
# 最適化
NFXP_opt <- optim(theta_true, logLH,
beta = beta, trans_mat = trans_mat_hat, state_df = state_df, df = data_gen,
control = list(fnscale = -1),
method = "Nelder-Mead")
end_time <- proc.time()
cat("Runtime:\n")
print((end_time - start_time)[[3]])
theta_est <- NFXP_opt$par
theta_est
hessian <- numDeriv::hessian(func = logLH, x = theta_est,
beta = beta,　trans_mat = trans_mat_hat, state_df = state_df, df = data_gen)
theta_se <- sqrt(diag(solve(-hessian)))
dplyr::tibble(theta_est, theta_se)
